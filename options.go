package otfreader

import (
	"os"
	"strings"

	"github.com/nsip/otf-reader/internal/util"
	"github.com/pkg/errors"
)

type Option func(*OTFReader) error

//
// apply all supplied options to the reader
// returns any error encountered while applying the options
//
func (rdr *OTFReader) setOptions(options ...Option) error {
	for _, opt := range options {
		if err := opt(rdr); err != nil {
			return err
		}
	}
	return nil
}

//
// set a name for this instance of an otf reader, if none
// provided a hashid will be created by default
//
func Name(name string) Option {
	return func(rdr *OTFReader) error {
		if len(name) > 0 {
			rdr.name = name
			return nil
		}
		// needs hashid
		rdr.name = util.GenerateName()
		return nil
	}
}

//
// create a unique id for the reader, if none
// provided a nuid will be generated by default
//
func ID(id string) Option {
	return func(rdr *OTFReader) error {
		if len(id) > 0 {
			rdr.ID = id
			return nil
		}
		rdr.ID = util.GenerateID()
		return nil
	}
}

//
// name of the external system that created the
// data being read
//
func ProviderName(name string) Option {
	return func(rdr *OTFReader) error {
		if len(name) > 0 {
			rdr.providerName = name
			return nil
		}
		rdr.providerName = "unspecified"
		return nil
	}
}

//
// the format of the input data, currently supported foramts
// are; csv, json & xml
//
func InputFormat(iformat string) Option {
	return func(rdr *OTFReader) error {
		if len(iformat) == 0 {
			return errors.New("otf-reader InputFormat cannot be empty.")
		}

		format := strings.ToLower(iformat)
		switch format {
		case "csv", "json", "xml":
			rdr.inputFormat = format
			return nil
		}
		return errors.New("otf-reader InputFormat " + iformat + " not supported (must be one of csv|json|xml)")
	}
}

//
// select the levelling/scaling method appropriate for data from this vendor
// can be one of
// prescribed: input data specifies level
// mapped-scale: uses external scale such as NAPLAN
// rules: uses aggregation rules such as 3 observations of indicator required to indicate success
//
func LevelMethod(lmethod string) Option {
	return func(rdr *OTFReader) error {
		if len(lmethod) == 0 {
			return errors.New("otf-reader LevelMethod cannot be empty.")
		}

		method := strings.ToLower(lmethod)
		switch method {
		case "prescribed", "mapped-scale", "rules":
			rdr.levelMethod = method
			return nil
		}
		return errors.New("otf-reader LevelMethod " + lmethod + " not supported (must be one of prescribed|mapped-scale|rules)")
	}
}

//
// select the alignment method appropriate data from this vendor
// can be one of
// prescribed: input data specifies alignment to NLP
// mapped: uses external alignment mapping such as through AC
// inferred: send data to text classifier to estbalish alignment
//
func AlignMethod(amethod string) Option {
	return func(rdr *OTFReader) error {
		if len(amethod) == 0 {
			return errors.New("otf-reader AlignMethod cannot be empty.")
		}

		method := strings.ToLower(amethod)
		switch method {
		case "prescribed", "mapped", "inferred":
			rdr.alignMethod = method
			return nil
		}
		return errors.New("otf-reader AlignMethod " + amethod + " not supported (must be one of prescribed|mapped|inferred)")
	}
}

//
// set the nats server communication port
// port value of 0 or less will result in default nats port 4222
//
func NatsPort(port int) Option {
	return func(rdr *OTFReader) error {
		if port > 0 {
			rdr.natsPort = port
			return nil
		}
		rdr.natsPort = 4222 //nats default
		return nil
	}
}

//
// set the nats server name or ip address
// empty string will result in localhost as defalt hostname
//
func NatsHostName(hostName string) Option {
	return func(rdr *OTFReader) error {
		if len(hostName) > 0 {
			rdr.natsHost = hostName
		}
		rdr.natsHost = "localhost" //nats default
		return nil
	}
}

//
// set the nats streaming server cluster name.
// empty string will result in nats default of 'test-cluster'
//
func NatsClusterName(clusterName string) Option {
	return func(rdr *OTFReader) error {
		if len(clusterName) > 0 {
			rdr.natsCluster = clusterName
		}
		rdr.natsCluster = "test-cluster" //nats default
		return nil
	}
}

//
// set the name of the nats topic to publish data once parsed
// from the input files
//
func TopicName(tName string) Option {
	return func(rdr *OTFReader) error {
		if len(tName) == 0 {
			return errors.New("must have TopicName (nats topic to which reader will publish parsed data).")
		}

		// topic regex check
		ok, err := util.ValidateNatsTopic(tName)
		if ok {
			rdr.publishTopic = tName
			return nil
		}
		return errors.Wrap(err, "TopicName option error")
	}

}

//
// specify the file-system folder to watch for new data
//
func WatchFolder(folderPath string) Option {
	return func(rdr *OTFReader) error {
		if len(folderPath) == 0 {
			folderPath = "."
		}
		if _, err := os.Stat(folderPath); os.IsNotExist(err) {
			// path/to/whatever does not exist
			return errors.Wrap(err, "WatchFolder option error:")
		}
		rdr.watchFolder = folderPath
		return nil
	}
}

//
// exxtension of the files to watch.
// can be used if mixed files in folder but only one type
// e.g. .csv files need to be parsed.
//
func WatchFileSuffix(suffix string) Option {
	return func(rdr *OTFReader) error {
		if len(suffix) > 0 {
			if !strings.HasPrefix(suffix, ".") { // add separator dot if not supplied
				suffix = "." + suffix
			}
			rdr.watchFileSuffix = suffix
		}
		return nil
	}
}
