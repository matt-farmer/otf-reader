package otfreader

import (
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/nsip/otf-reader/internal/util"
	"github.com/pkg/errors"
	"github.com/radovskyb/watcher"
)

type Option func(*OTFReader) error

//
// apply all supplied options to the reader
// returns any error encountered while applying the options
//
func (rdr *OTFReader) setOptions(options ...Option) error {
	for _, opt := range options {
		if err := opt(rdr); err != nil {
			return err
		}
	}
	return nil
}

//
// set a name for this instance of an otf reader, if none
// provided a hashid will be created by default
//
func Name(name string) Option {
	return func(rdr *OTFReader) error {
		if len(name) > 0 {
			rdr.name = name
			return nil
		}
		// needs hashid
		rdr.name = util.GenerateName()
		return nil
	}
}

//
// create a unique id for the reader, if none
// provided a nuid will be generated by default
//
func ID(id string) Option {
	return func(rdr *OTFReader) error {
		if len(id) > 0 {
			rdr.ID = id
			return nil
		}
		rdr.ID = util.GenerateID()
		return nil
	}
}

//
// name of the external system that created the
// data being read
//
func ProviderName(name string) Option {
	return func(rdr *OTFReader) error {
		if len(name) > 0 {
			rdr.providerName = name
			return nil
		}
		rdr.providerName = "unspecified"
		return nil
	}
}

//
// the format of the input data, currently supported foramts
// are; csv, json & xml
//
func InputFormat(iformat string) Option {
	return func(rdr *OTFReader) error {
		if len(iformat) == 0 {
			return errors.New("otf-reader InputFormat cannot be empty.")
		}

		format := strings.ToLower(iformat)
		switch format {
		case "csv", "json":
			rdr.inputFormat = format
			return nil
		}
		return errors.New("otf-reader InputFormat " + iformat + " not supported (must be one of csv|json)")
	}
}

//
// select the levelling/scaling method appropriate for data from this vendor
// can be one of
// prescribed: input data specifies level
// mapped-scale: uses external scale such as NAPLAN
// rules: uses aggregation rules such as 3 observations of indicator required to indicate success
//
func LevelMethod(lmethod string) Option {
	return func(rdr *OTFReader) error {
		if len(lmethod) == 0 {
			return errors.New("otf-reader LevelMethod cannot be empty.")
		}

		method := strings.ToLower(lmethod)
		switch method {
		case "prescribed", "mapped-scale", "rules":
			rdr.levelMethod = method
			return nil
		}
		return errors.New("otf-reader LevelMethod " + lmethod + " not supported (must be one of prescribed|mapped-scale|rules)")
	}
}

//
// select the alignment method appropriate data from this vendor
// can be one of
// prescribed: input data specifies alignment to NLP
// mapped: uses external alignment mapping such as through AC
// inferred: send data to text classifier to estbalish alignment
//
func AlignMethod(amethod string) Option {
	return func(rdr *OTFReader) error {
		if len(amethod) == 0 {
			return errors.New("otf-reader AlignMethod cannot be empty.")
		}

		method := strings.ToLower(amethod)
		switch method {
		case "prescribed", "mapped", "inferred":
			rdr.alignMethod = method
			return nil
		}
		return errors.New("otf-reader AlignMethod " + amethod + " not supported (must be one of prescribed|mapped|inferred)")
	}
}

//
// set the nats server communication port
// port value of 0 or less will result in default nats port 4222
//
func NatsPort(port int) Option {
	return func(rdr *OTFReader) error {
		if port > 0 {
			rdr.natsPort = port
			return nil
		}
		rdr.natsPort = 4222 //nats default
		return nil
	}
}

//
// set the nats server name or ip address
// empty string will result in localhost as defalt hostname
//
func NatsHostName(hostName string) Option {
	return func(rdr *OTFReader) error {
		if len(hostName) > 0 {
			rdr.natsHost = hostName
		}
		rdr.natsHost = "localhost" //nats default
		return nil
	}
}

//
// set the nats streaming server cluster name.
// empty string will result in nats default of 'test-cluster'
//
func NatsClusterName(clusterName string) Option {
	return func(rdr *OTFReader) error {
		if len(clusterName) > 0 {
			rdr.natsCluster = clusterName
		}
		rdr.natsCluster = "test-cluster" //nats default
		return nil
	}
}

//
// set the name of the nats topic to publish data once parsed
// from the input files
//
func TopicName(tName string) Option {
	return func(rdr *OTFReader) error {
		if len(tName) == 0 {
			return errors.New("must have TopicName (nats topic to which reader will publish parsed data).")
		}

		// topic regex check
		ok, err := util.ValidateNatsTopic(tName)
		if ok {
			rdr.publishTopic = tName
			return nil
		}
		return errors.Wrap(err, "TopicName option error")
	}

}

//
// configure the internal file watcher
//
func Watcher(folder string, fileSuffix string, interval string, recursive bool, dotfiles bool, ignore string) Option {
	return func(rdr *OTFReader) error {

		rdr.watcher = watcher.New()
		rdr.watcher.IgnoreHiddenFiles(!dotfiles)
		rdr.dotfiles = dotfiles

		// If no files/folders were specified, watch the current directory.
		if len(folder) == 0 {
			var osErr error
			folder, osErr = os.Getwd()
			if osErr != nil {
				return errors.Wrap(osErr, "no watch folder specified, and cannot determine current working diectory")
			}
		}
		rdr.watchFolder = folder

		// Get any of the paths to ignore.
		ignoredPaths := strings.Split(ignore, ",")
		for _, path := range ignoredPaths {
			trimmed := strings.TrimSpace(path)
			if trimmed == "" {
				continue
			}

			err := rdr.watcher.Ignore(trimmed)
			if err != nil {
				return errors.Wrap(err, "unable to add ignore folder "+trimmed)
			}
		}
		rdr.ignore = ignore

		// Only files that match the regular expression for file suffix during file listings
		// will be watched.
		if len(fileSuffix) > 0 {
			trimSuffix := strings.Trim(fileSuffix, ".")
			r := regexp.MustCompile("([^\\s]+(\\.(?i)(" + trimSuffix + "))$)")
			rdr.watcher.AddFilterHook(watcher.RegexFilterHook(r, false))
		}
		rdr.watchFileSuffix = fileSuffix

		// Add the watch folder specified.
		if recursive {
			if err := rdr.watcher.AddRecursive(folder); err != nil {
				return errors.Wrap(err, "unable to add watch folder "+folder+" recursively")
			}
		} else {
			if err := rdr.watcher.Add(folder); err != nil {
				return errors.Wrap(err, "unable to add watch folder "+folder)
			}
		}
		rdr.recursive = recursive

		// Parse the interval string into a time.Duration.
		parsedInterval, err := time.ParseDuration(interval)
		if err != nil {
			return errors.Wrap(err, "unable to parse watcher interval as duration")
		}
		rdr.interval = parsedInterval

		return nil
	}

}
